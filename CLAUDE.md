# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is an R package project named `xcmsVis`, a parallel package to XCMS that provides ggplot2 implementations of XCMS plotting functions for modern, interactive visualizations.

## Project Task Management

**IMPORTANT**: This project uses a structured task management system to minimize token usage:

- **`instructions.md`**: Contains ONLY current/active tasks. Keep this file as lightweight as possible.
- **`completed_tasks.md`**: Archive of all completed tasks with detailed documentation.
- **`future_tasks.md`**: Long-term development roadmap and planned features.

When working on tasks:
1. Check `instructions.md` for current work
2. Move completed tasks to `completed_tasks.md` with details
3. Keep `instructions.md` minimal to reduce token consumption
4. Reference other files for context rather than duplicating information

## R Package Development Commands

### Package Setup and Building
```r
# Install development dependencies
install.packages(c("devtools", "roxygen2", "testthat", "usethis"))

# Build package documentation from roxygen comments
devtools::document()

# Install the package locally
devtools::install()

# Build package bundle
devtools::build()

# Check package (runs R CMD check)
devtools::check()
```

### Testing
```r
# Run all tests
devtools::test()

# Run tests with coverage
covr::package_coverage()

# Run a specific test file
testthat::test_file("tests/testthat/test-filename.R")
```

### Development Workflow
```r
# Load package for interactive development
devtools::load_all()

# Create new function/data documentation
usethis::use_r("function_name")

# Add test file
usethis::use_test("function_name")

# Add package dependency
usethis::use_package("package_name")
```

## R Package Structure

When creating R package files, follow this structure:

- `DESCRIPTION` - Package metadata and dependencies
- `NAMESPACE` - Package namespace (auto-generated by roxygen2)
- `R/` - R source code files
- `man/` - Documentation files (auto-generated by roxygen2)
- `tests/testthat/` - Unit tests
- `vignettes/` - Long-form documentation
- `data/` - Package datasets
- `inst/` - Additional files to be installed
- `dev-docs/` - Research documentation and implementation guides (not part of package, ignored by R CMD build)

## Code Style

The project follows standard R package conventions:
- Use 2 spaces for indentation (configured in .Rproj file)
- Strip trailing whitespace (configured in .Rproj file)
- Auto-append newline to files (configured in .Rproj file)
- Use UTF-8 encoding

## Testing Requirements

**IMPORTANT**: All functions MUST have comprehensive tests:
- Test compatibility with both XCMSnExp and XcmsExperiment objects
- Even if examples/vignettes focus on XcmsExperiment, tests must verify XCMSnExp works
- Write tests in `tests/testthat/test-*.R` files
- Use `testthat::test_file()` to run individual test files
- Ensure all major code paths are covered

## Bioconductor Parallel Processing

**IMPORTANT**: Always use `SerialParam()` for example code and tests:

```r
library(BiocParallel)

# Always include BPPARAM = SerialParam() for functions that support it:
xdata <- readMsExperiment(spectraFiles = files, BPPARAM = SerialParam())
xdata <- findChromPeaks(xdata, param = cwp, BPPARAM = SerialParam())

# Note: groupChromPeaks does NOT have BPPARAM parameter
xdata <- groupChromPeaks(xdata, param = pdp)
```

**Why SerialParam?**
- **Faster for small datasets**: Avoids parallel processing overhead
- **Eliminates warnings**: Prevents "'package:stats' may not be available" warnings
- **Cleaner output**: No parallel-related messages
- **Better for reproducibility**: Consistent behavior across systems

**When to use SerialParam:**
- All test files (`tests/testthat/`)
- All vignettes and examples
- Any code with small sample sizes (< 20 samples typically)

**Which functions support BPPARAM:**
- âœ… `readMsExperiment()` - supports BPPARAM
- âœ… `findChromPeaks()` - supports BPPARAM
- âŒ `groupChromPeaks()` - does NOT support BPPARAM
- âŒ `adjustRtime()` - does NOT support BPPARAM

**Note**: Users can still use parallel processing in production by omitting BPPARAM or setting their own parallel backend.

## Adding New Functions

When implementing new XCMS plotting functions:

1. Identify XCMS plotting function to implement
2. Locate source code in XCMS GitHub: https://github.com/sneumann/xcms
3. Study the function's purpose, parameters, and output
4. Implement ggplot2 version in `R/gplot*.R`
5. Add roxygen2 documentation
6. Update NAMESPACE if needed
7. Add tests in `tests/testthat/test-*.R` (REQUIRED - test both object types)
8. Add examples to vignette (focus on XcmsExperiment)
9. Update NEWS.md
10. Run `devtools::check()`
11. Move task from instructions.md to `completed_tasks.md` when done

## Key Resources

- **XCMS Repository**: https://github.com/sneumann/xcms
- **Metabonaut Tutorials**: https://github.com/rformassspectrometry/Metabonaut
- **Original Discussion**: https://github.com/sneumann/xcms/issues/551
- **Package Structure Reference**: `/mnt/c/Users/tmh331/Desktop/gits/remoteUpdater`
- **Function Reference**: `/mnt/c/Users/tmh331/Desktop/gits/_Introduction to Nutritional Metabolomics/inm-booklet/scripts/funs.R`
- **S4 Implementation Guide**: `dev-docs/` - Comprehensive guides for implementing S4 methods like XCMS

## Important Conventions

- Follow XCMS conventions for object types and methods
- Maintain compatibility with both XCMSnExp and xcmsExperiment objects
- Use consistent naming: `gplot*` prefix for all plotting functions
- Include tooltip text for plotly compatibility
- Write comprehensive roxygen2 documentation
- Add examples (even if marked `\dontrun`)
- When tasks are completed, move them to `completed_tasks.md`

## S4 Method Implementation Pattern

**IMPORTANT**: When implementing functions that support both XCMSnExp and XcmsExperiment:

### DO: Use Shared Implementation Pattern

```r
# Internal implementation function (single source of truth)
.gplot_function_impl <- function(object, ...) {
  .validate_xcms_object(object)

  # Use helper functions that handle both object types
  sample_data <- .get_sample_data(object)
  spectra_data <- .get_spectra_data(object)

  # All plotting logic here
  # ...
}

# Thin S4 method wrappers (just dispatch)
setMethod("gplot_function", "XCMSnExp",
          function(object, ...) {
            .gplot_function_impl(object, ...)
          })

setMethod("gplot_function", "XcmsExperiment",
          function(object, ...) {
            .gplot_function_impl(object, ...)
          })
```

### DON'T: Duplicate Code in Methods

âŒ **BAD** - Duplicating identical code in both methods:
```r
setMethod("gplot_function", "XCMSnExp", function(...) {
  # 100+ lines of code
})

setMethod("gplot_function", "XcmsExperiment", function(...) {
  # Same 100+ lines of code (maintenance nightmare!)
})
```

### Helper Functions

Use these internal helpers that already handle object type differences:
- `.validate_xcms_object(object)` - Validates object type
- `.get_sample_data(object)` - Extracts sample metadata
- `.get_spectra_data(object)` - Extracts spectra/feature data

These helpers use S4 dispatch internally, so your implementation function doesn't need to know about object types.

## Git Workflow

- Default branch: `main`
- **ALWAYS use semantic-release commit message format** (conventional commits):
  - `feat:` - New feature (triggers minor version bump)
  - `fix:` - Bug fix (triggers patch version bump)
  - `docs:` - Documentation changes only
  - `style:` - Code style changes (formatting, etc.)
  - `refactor:` - Code refactoring
  - `test:` - Adding or updating tests
  - `chore:` - Maintenance tasks
  - Example: `feat: add gplotEIC function for extracted ion chromatograms`
- GitHub Actions will automatically:
  - Run R CMD check on push/PR
  - Deploy pkgdown site on push to main
  - Create releases via semantic-release based on commit messages
- Always commit with co-authorship footer when using Claude Code

## Pre-Commit Checklist

**IMPORTANT**: Before committing changes, ALWAYS run these checks in order:

### 0. Update DESCRIPTION (if needed)

When modifying functions, check if DESCRIPTION needs updates:
- Add new package dependencies to `Imports:` if using new packages
- Update `Suggests:` for optional dependencies (testing, vignettes)
- Ensure all imported packages are listed

### 1. Regenerate Documentation
```r
# Update NAMESPACE and .Rd files from roxygen2 comments
roxygen2::roxygenize()
```

This ensures all function documentation and imports are up to date.

### 2. R CMD Check
```r
# Check package for errors, warnings, and notes
devtools::check()
```

Fix all errors and warnings before committing. Address notes if relevant.

### 3. Build pkgdown Site
```r
# Load all package code
devtools::load_all()

# Build pkgdown site locally
pkgdown::build_site()
```

Check for:
- No errors during site build
- All vignettes render correctly
- All function documentation displays properly
- No broken links or missing references

Only commit after all three checks pass successfully.

### 4. Reinstall Package
```r
# Reinstall the package to ensure all changes are properly loaded
devtools::install()
```

This ensures the package is fully functional after your changes.

### 5. Commit Changes

After all checks pass, commit your changes using semantic-release format:
- Use conventional commit messages (feat:, fix:, docs:, etc.)
- Always include co-authorship footer when using Claude Code
- Example:
```bash
git add -A
git commit -m "feat: add new visualization function

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

## Pre-Push Checklist

After committing, verify everything is working before pushing to GitHub:
- Ensure `devtools::check()` passes with no errors/warnings
- Ensure `pkgdown::build_site()` completes without errors
- Review git status to ensure no unintended files are included

## Task Management

**IMPORTANT**: Do NOT start working on new tasks from instructions.md unless explicitly told to do so by the user. Wait for the user to give the go-ahead before proceeding with tasks.

**CRITICAL**: Make commits frequently after completing each task or logical unit of work:
- Commit after each completed task from instructions.md
- Don't batch multiple tasks into one commit
- Use semantic commit format for each commit (feat:, fix:, docs:, etc.)
- This provides better granularity and makes it easier to track changes
- Example workflow:
  1. Complete task 1 â†’ commit
  2. Complete task 2 â†’ commit
  3. Complete task 3 â†’ commit
  etc.
