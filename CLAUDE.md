# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working
with code in this repository.

## Project Overview

This is an R package project named `xcmsVis`, a parallel package to XCMS
that provides ggplot2 implementations of XCMS plotting functions for
modern, interactive visualizations.

## Project Task Management

**IMPORTANT**: This project uses a structured task management system to
minimize token usage:

- **`instructions.md`**: Contains ONLY current/active tasks. Keep this
  file as lightweight as possible.
- **`completed_tasks.md`**: Archive of all completed tasks with detailed
  documentation.
- **`future_tasks.md`**: Long-term development roadmap and planned
  features.

When working on tasks: 1. Check `instructions.md` for current work 2.
Move completed tasks to `completed_tasks.md` with details 3. Keep
`instructions.md` minimal to reduce token consumption 4. Reference other
files for context rather than duplicating information

## R Package Development Commands

### Package Setup and Building

``` r
# Install development dependencies
install.packages(c("devtools", "roxygen2", "testthat", "usethis"))

# Build package documentation from roxygen comments
devtools::document()

# Install the package locally
devtools::install()

# Build package bundle
devtools::build()

# Check package (runs R CMD check)
devtools::check()
```

### Testing

``` r
# Run all tests (can be slow)
devtools::test()

# Run a specific test file (PREFERRED - faster for development)
testthat::test_file("tests/testthat/test-filename.R")

# Run tests with coverage
covr::package_coverage()
```

**IMPORTANT**: When working on specific functions, ALWAYS use
[`testthat::test_file()`](https://testthat.r-lib.org/reference/test_file.html)
to run only the relevant test file. Running all tests with
`devtools::test()` takes much longer than necessary.

### Development Workflow

``` r
# Load package for interactive development
devtools::load_all()

# Create new function/data documentation
usethis::use_r("function_name")

# Add test file
usethis::use_test("function_name")

# Add package dependency
usethis::use_package("package_name")
```

## R Package Structure

When creating R package files, follow this structure:

- `DESCRIPTION` - Package metadata and dependencies
- `NAMESPACE` - Package namespace (auto-generated by roxygen2)
- `R/` - R source code files
- `man/` - Documentation files (auto-generated by roxygen2)
- `tests/testthat/` - Unit tests
- `vignettes/` - Long-form documentation
- `data/` - Package datasets
- `inst/` - Additional files to be installed
- `dev-docs/` - Research documentation and implementation guides (not
  part of package, ignored by R CMD build)

## Code Style

The project follows standard R package conventions: - Use 2 spaces for
indentation (configured in .Rproj file) - Strip trailing whitespace
(configured in .Rproj file) - Auto-append newline to files (configured
in .Rproj file) - Use UTF-8 encoding

## Testing Requirements

**IMPORTANT**: All functions MUST have comprehensive tests: - Test
compatibility with both XCMSnExp and XcmsExperiment objects - Even if
examples/vignettes focus on XcmsExperiment, tests must verify XCMSnExp
works - Write tests in `tests/testthat/test-*.R` files - Use
[`testthat::test_file()`](https://testthat.r-lib.org/reference/test_file.html)
to run individual test files - Ensure all major code paths are covered

## Bioconductor Parallel Processing

**IMPORTANT**: Always use
[`SerialParam()`](https://rdrr.io/pkg/BiocParallel/man/SerialParam-class.html)
for example code and tests:

``` r
library(BiocParallel)

# Always include BPPARAM = SerialParam() for functions that support it:
xdata <- readMsExperiment(spectraFiles = files, BPPARAM = SerialParam())
xdata <- findChromPeaks(xdata, param = cwp, BPPARAM = SerialParam())

# Note: groupChromPeaks does NOT have BPPARAM parameter
xdata <- groupChromPeaks(xdata, param = pdp)
```

**Why SerialParam?** - **Faster for small datasets**: Avoids parallel
processing overhead - **Eliminates warnings**: Prevents â€œâ€˜package:statsâ€™
may not be availableâ€ warnings - **Cleaner output**: No parallel-related
messages - **Better for reproducibility**: Consistent behavior across
systems

**When to use SerialParam:** - All test files (`tests/testthat/`) - All
vignettes and examples - Any code with small sample sizes (\< 20 samples
typically)

**Which functions support BPPARAM:** - âœ… `readMsExperiment()` -
supports BPPARAM - âœ… `findChromPeaks()` - supports BPPARAM - âŒ
`groupChromPeaks()` - does NOT support BPPARAM - âŒ `adjustRtime()` -
does NOT support BPPARAM

**Note**: Users can still use parallel processing in production by
omitting BPPARAM or setting their own parallel backend.

## Adding New Functions

When implementing new XCMS plotting functions:

1.  Identify XCMS plotting function to implement
2.  Locate source code in XCMS GitHub:
    <https://github.com/sneumann/xcms>
3.  Study the functionâ€™s purpose, parameters, and output
4.  **Implement ggplot2 version in `R/gplot*.R` - FOLLOW XCMS CODE AS
    CLOSELY AS POSSIBLE**
5.  Add roxygen2 documentation
6.  Update NAMESPACE if needed
7.  Add tests in `tests/testthat/test-*.R` (REQUIRED - test both object
    types)
8.  Add examples to vignette (focus on XcmsExperiment)
9.  Update NEWS.md
10. Run `devtools::check()`
11. Move task from instructions.md to `completed_tasks.md` when done

## CRITICAL: Faithful Implementation of XCMS Functions

**IMPORTANT**: When implementing ggplot2 versions of XCMS functions,
follow the original XCMS implementation as closely as possible to avoid
subtle bugs and behavioral differences.

### Why This Matters

The XCMS codebase has been refined over many years and contains
important edge case handling that may not be obvious: - Proper handling
of NA values in chromatographic data - Correct polygon rendering with
data gaps - Edge cases in peak detection and visualization - Proper
coordinate transformations

### Implementation Guidelines

1.  **Study the XCMS source code thoroughly** before implementing:

    - Read the entire function, not just the main logic
    - Identify all edge case handling
    - Note how data transformations are performed
    - Look for helper functions that handle special cases

2.  **ALWAYS reuse XCMS internal functions when possible**:

    - **DO**: Call XCMS internal functions directly using
      `xcms:::functionName()`
    - **DO**: Reuse XCMSâ€™s data processing, mathematical, and
      algorithmic functions
    - **DONâ€™T**: Reimplement functions that already exist in XCMS
    - **ONLY write your own functions** when the XCMS code cannot be
      separated from the base R plotting functionality we need to
      replace
    - This ensures perfect compatibility and avoids subtle
      implementation bugs
    - Examples of what to reuse:
      - `xcms:::descendMin()` - density local minima finding
      - Any mathematical or statistical functions
      - Data transformation and filtering functions
      - Peak grouping and detection algorithms
    - Examples of what to reimplement:
      - Base R plotting calls
        ([`plot()`](https://rdrr.io/r/graphics/plot.default.html),
        [`points()`](https://rdrr.io/r/graphics/points.html),
        [`rect()`](https://rdrr.io/r/graphics/rect.html)) â†’ replace with
        ggplot2
      - Plot layout and styling â†’ replace with ggplot2/patchwork
      - Visual elements specific to base R graphics

3.  **Mirror XCMS logic structure** in your ggplot2 implementation:

    - Use similar variable names where possible
    - Follow the same sequence of operations
    - Preserve data filtering and validation logic
    - Keep the same coordinate transformations

4.  **Pay special attention to**:

    - NA value handling (filtering, propagation)
    - Data gaps and breaks in visualizations
    - Polygon/geometry rendering edge cases
    - Coordinate system transformations
    - Default parameter values
    - **Parameter meanings**: Always read the XCMS documentation
      carefully
      - Example: `stacked` in `plotChromatogramsOverlay()` is a
        PROPORTION (0-1), not an absolute value
      - With `stacked = 1`, y-axis is split 50/50 between stacking
        region and intensity region
      - XCMS documentation is authoritative - donâ€™t guess parameter
        behavior

5.  **Example: Reusing XCMS internal functions**

    ``` r
    # BAD - Reimplementing a function that exists in XCMS:
    .descendMin <- function(y, istart = which.max(y)) {
      # ... custom implementation that may have subtle bugs
    }

    # GOOD - Using XCMS's internal function directly:
    feat_range <- xcms:::descendMin(dens_y_copy, max_y)

    # This ensures perfect compatibility and avoids reimplementation bugs
    ```

6.  **Example: Polygon rendering with NA breaks**

    ``` r
    # XCMS approach (CORRECT):
    nona <- !is.na(ys)  # Filter NA values
    if (length(xs_all)) {
        xs_all <- c(xs_all, NA)  # Insert NA to break polygon
        ys_all <- c(ys_all, NA)
    }
    xs_all <- c(xs_all, xs[nona])
    ys_all <- c(ys_all, ys[nona])

    # Don't simplify without understanding why XCMS does it this way!
    ```

7.  **When in doubt**:

    - Check the XCMS source code again
    - Look for XCMS internal functions you can reuse before writing your
      own
    - Test with edge cases (NA values, empty data, single points)
    - Compare output visually with original XCMS function

### Testing Requirements

- Test with data that has NA values
- Test with data that has gaps
- Test with single-point chromatograms
- Test with empty/zero-length data
- Compare visual output with XCMS when possible

## Finding XCMS Source Code

When you need to find the source code for an XCMS function to implement:

1.  **Use the branch reference format** (preferred): This always gets
    the latest code from the branch:

        https://raw.githubusercontent.com/sneumann/xcms/refs/heads/devel/R/FILENAME.R

    - Example:
      `https://raw.githubusercontent.com/sneumann/xcms/refs/heads/devel/R/methods-group-features.R`
    - This automatically uses the latest code from the `devel` branch

2.  **Alternative - Use specific commit hash** (for reproducibility):

        https://raw.githubusercontent.com/sneumann/xcms/COMMIT_HASH/R/FILENAME.R

    - Example:
      `https://raw.githubusercontent.com/sneumann/xcms/e2f76c8512bd0244f9524c075fe240138335f3e4/R/methods-group-features.R`
    - Use this when you need a specific version

3.  **Common XCMS source files**:

    - `methods-group-features.R` - Feature grouping methods
      (plotFeatureGroups)
    - `functions-XCMSnExp.R` - XCMSnExp-specific functions
    - `methods-XCMSnExp.R` - XCMSnExp S4 methods
    - `functions-Chromatogram.R` - Chromatogram plotting functions
    - `functions-xcmsSet.R` - Legacy xcmsSet functions

4.  **Use WebFetch or Task tool**: Once you have the URL, use WebFetch
    to retrieve the source code

## Key Resources

- **XCMS Repository**: <https://github.com/sneumann/xcms>
- **XCMS Source Code**: <https://github.com/sneumann/xcms/tree/devel/R>
- **Metabonaut Tutorials**:
  <https://github.com/rformassspectrometry/Metabonaut>
- **Original Discussion**: <https://github.com/sneumann/xcms/issues/551>
- **Package Structure Reference**:
  `/mnt/c/Users/tmh331/Desktop/gits/remoteUpdater`
- **Function Reference**:
  `/mnt/c/Users/tmh331/Desktop/gits/_Introduction to Nutritional Metabolomics/inm-booklet/scripts/funs.R`
- **S4 Implementation Guide**: `dev-docs/` - Comprehensive guides for
  implementing S4 methods like XCMS

## Important Conventions

- Follow XCMS conventions for object types and methods
- Maintain compatibility with both XCMSnExp and xcmsExperiment objects
- Use consistent naming: `gplot*` prefix for all plotting functions
- Include tooltip text for plotly compatibility
- Write comprehensive roxygen2 documentation
- Add examples (even if marked `\dontrun`)
- When tasks are completed, move them to `completed_tasks.md`

## S4 Method Implementation Pattern

**IMPORTANT**: When implementing functions that support both XCMSnExp
and XcmsExperiment:

### DO: Use Shared Implementation Pattern

``` r
# Internal implementation function (single source of truth)
.gplot_function_impl <- function(object, ...) {
  .validate_xcms_object(object)

  # Use helper functions that handle both object types
  sample_data <- .get_sample_data(object)
  spectra_data <- .get_spectra_data(object)

  # All plotting logic here
  # ...
}

# Thin S4 method wrappers (just dispatch)
setMethod("gplot_function", "XCMSnExp",
          function(object, ...) {
            .gplot_function_impl(object, ...)
          })

setMethod("gplot_function", "XcmsExperiment",
          function(object, ...) {
            .gplot_function_impl(object, ...)
          })
```

### DONâ€™T: Duplicate Code in Methods

âŒ **BAD** - Duplicating identical code in both methods:

``` r
setMethod("gplot_function", "XCMSnExp", function(...) {
  # 100+ lines of code
})

setMethod("gplot_function", "XcmsExperiment", function(...) {
  # Same 100+ lines of code (maintenance nightmare!)
})
```

### Helper Functions

Use these internal helpers that already handle object type
differences: - `.validate_xcms_object(object)` - Validates object type -
`.get_sample_data(object)` - Extracts sample metadata -
`.get_spectra_data(object)` - Extracts spectra/feature data

These helpers use S4 dispatch internally, so your implementation
function doesnâ€™t need to know about object types.

## Git Workflow

- Default branch: `main`
- **ALWAYS use semantic-release commit message format** (conventional
  commits):
  - `feat:` - New feature (triggers minor version bump)
  - `fix:` - Bug fix (triggers patch version bump)
  - `docs:` - Documentation changes only
  - `style:` - Code style changes (formatting, etc.)
  - `refactor:` - Code refactoring
  - `test:` - Adding or updating tests
  - `chore:` - Maintenance tasks
  - Example:
    `feat: add gplotEIC function for extracted ion chromatograms`
- GitHub Actions will automatically:
  - Run R CMD check on push/PR
  - Deploy pkgdown site on push to main
  - Create releases via semantic-release based on commit messages
- Always commit with co-authorship footer when using Claude Code

## Pre-Commit Checklist

**IMPORTANT**: Before committing changes, ALWAYS run these checks in
order:

### 0. Update DESCRIPTION (if needed)

When modifying functions, check if DESCRIPTION needs updates: - Add new
package dependencies to `Imports:` if using new packages - Update
`Suggests:` for optional dependencies (testing, vignettes) - Ensure all
imported packages are listed

### 1. Regenerate Documentation

``` r
# Update NAMESPACE and .Rd files from roxygen2 comments
roxygen2::roxygenize()
```

This ensures all function documentation and imports are up to date.

### 2. R CMD Check

``` r
# Check package for errors, warnings, and notes
devtools::check()
```

Fix all errors and warnings before committing. Address notes if
relevant.

### 3. Build pkgdown Site

``` r
# Load all package code
devtools::load_all()

# Build pkgdown site locally
pkgdown::build_site()
```

Check for: - No errors during site build - All vignettes render
correctly - All function documentation displays properly - No broken
links or missing references

Only commit after all three checks pass successfully.

### 4. Reinstall Package

``` r
# Reinstall the package to ensure all changes are properly loaded
devtools::install()
```

This ensures the package is fully functional after your changes.

### 5. Commit Changes

After all checks pass, commit your changes using semantic-release
format: - Use conventional commit messages (feat:, fix:, docs:, etc.) -
Always include co-authorship footer when using Claude Code - Example:

``` bash
git add -A
git commit -m "feat: add new visualization function

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

## Pre-Push Checklist

After committing, verify everything is working before pushing to
GitHub: - Ensure `devtools::check()` passes with no errors/warnings -
Ensure
[`pkgdown::build_site()`](https://pkgdown.r-lib.org/reference/build_site.html)
completes without errors - Review git status to ensure no unintended
files are included

## Task Management

**IMPORTANT**: Do NOT start working on new tasks from instructions.md
unless explicitly told to do so by the user. Wait for the user to give
the go-ahead before proceeding with tasks.

**CRITICAL**: Make commits frequently after completing each task or
logical unit of work: - Commit after each completed task from
instructions.md - Donâ€™t batch multiple tasks into one commit - Use
semantic commit format for each commit (feat:, fix:, docs:, etc.) - This
provides better granularity and makes it easier to track changes -
Example workflow: 1. Complete task 1 â†’ commit 2. Complete task 2 â†’
commit 3. Complete task 3 â†’ commit etc.
